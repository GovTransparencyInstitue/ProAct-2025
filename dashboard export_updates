#!/usr/bin/env Rscript

## ---- ProACT ---- ##
## First time edited: 12/11/2025, by Dani
## Last time edited: 02/06/2026, by Ivana
##
## Aggregation by: Country + Year + Product_Market + Contract_Value (HIGH/MED/LOW) + Supply_Type
## Year filter: 2000-2020
## Handles missing price data gracefully by setting values to NA for affected tiers
##
## NEW price tiers:
##   HIGH: >= $400,000
##   MED:  $50,000 - $399,999
##   LOW:  < $50,000
##
## Supply types: WORKS, SERVICES, SUPPLIES (+ NA for missing)
##
## If price data (bid_priceusd) is missing for a country, all three tiers will have NA values
## Added: missing rate for the tier 

suppressPackageStartupMessages({
  library(optparse)
  library(tidyverse)
  library(lubridate)
  library(data.table)
  library(readxl)
})

# Load ISO matcher for ISO3 codes
iso_matcher <- fread("/gti/tmp/ProACT/Utility_datasets/ISO_matcher.csv") # Server PATH
setnames(iso_matcher, tolower(names(iso_matcher)))

correspondence_table <- readxl::read_excel(
  "/gti/tmp/ProACT/Utility_datasets/Correspondence_table_UNDP2025.xlsx",
  sheet = "cpv_labels"
)
correspondence_table <- as.data.table(correspondence_table)

# Load indicator names lookup table
ind_names_lookup <- readxl::read_excel(
  "/gti/tmp/ProACT/Utility_datasets/Short_Ind_names.xlsx"
)
ind_names_lookup <- as.data.table(ind_names_lookup)
setnames(ind_names_lookup, gsub(" ", "_", names(ind_names_lookup))) # Replace spaces with underscores

# ---------- CLI ----------
opt_list <- list(
  make_option(c("--input-dir"), type="character", default="/var/tmp/ivana/Export 3"),
  make_option(c("--output-dir"), type="character", default="/var/tmp/ivana/export_dashboard ready"),
  make_option(c("--output-subdir"), type="character", default=format(Sys.Date(), "%m%d")),
  make_option(c("--verbose"), action="store_true", default=FALSE)
)
opt <- parse_args(OptionParser(option_list = opt_list))

vcat <- function(...) {
  if (isTRUE(opt$verbose)) {
    timestamp <- format(Sys.time(), "%H:%M:%S")
    cat(sprintf("[%s - INFO][ProACT_exports]", timestamp), sprintf(...), "\n")
  }
}

# ---------- I/O ----------
out_dir <- file.path(opt$`output-dir`, opt$`output-subdir`)
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
vcat("Output: %s", out_dir)

# ---------- Indicators lists ----------
list_of_indicators_new <- c(
  "ind_tr_proc_type",
  "ind_tr_buyer_id",
  "ind_tr_supplier_id",
  "ind_tr_bidder_id",
  "ind_tr_call_pub",
  "ind_tr_bid_deadline",
  "ind_tr_bid_opening",
  "ind_tr_award_pub",
  "ind_tr_prod_code",
  "ind_tr_buyer_loc",
  "ind_tr_supplier_loc",
  "ind_tr_impl_loc",
  "ind_tr_bidder_loc",
  "ind_tr_contract_value",
  "ind_tr_benford",
  "ind_tr_index",
  "ind_op_open_proc",
  "ind_op_nonopen_proc",
  "ind_op_adv_period",
  "ind_op_short_adv_flag",
  "ind_adm_dec_period",
  "ind_adm_long_dec_flag",
  "ind_comp_avg_bids",
  "ind_comp_single_bid",
  "ind_comp_new_suppliers",
  "ind_comp_sector_concentration",
  "ind_comp_bidder_non_l",
  "ind_comp_foreign_suppliers",
  "ind_comp_tax_haven_suppliers",
  "ind_econ_sector_composition",
  "ind_econ_buyer_concentration",
  "ind_impl_cost_overrun",
  "ind_impl_time_overrun"
)
list_of_indicators <- list_of_indicators_new

## --------------------------------------------------
## CHANGE (A1): Missingness threshold updated to 30% 
## --------------------------------------------------
MISSINGNESS_THRESHOLD <- 0.30

## --------------------------------------------------
## CHANGE (A2): Eligibility masks for sample-restricted indicators
## - Missingness is computed ONLY among eligible observations (within sample restriction)
## - This prevents penalizing NA created by sample restrictions upstream.
## --------------------------------------------------

get_proc_flags <- function(dt) {
  proc_clean <- if ("tender_proceduretype" %in% names(dt)) {
    toupper(trimws(as.character(dt$tender_proceduretype)))
  } else {
    rep(NA_character_, nrow(dt))
  }
  list(
    open = !is.na(proc_clean) & proc_clean == "OPEN",
    competitive = !is.na(proc_clean) & proc_clean %in% c("OPEN", "RESTRICTED")
  )
}

IND_COMPETITIVE_ONLY <- c(
  "ind_tr_bidder_id",
  "ind_tr_call_pub",
  "ind_tr_bid_deadline",
  "ind_tr_bid_opening",
  "ind_tr_bidder_loc",
  "ind_comp_avg_bids",
  "ind_comp_single_bid",
  "ind_comp_new_suppliers",
  "ind_comp_sector_concentration",
  "ind_comp_bidder_non_l",
  "ind_comp_foreign_suppliers",
  "ind_comp_tax_haven_suppliers"
)

IND_OPEN_ONLY <- c(
  "ind_op_open_proc",
  "ind_op_nonopen_proc",
  "ind_op_adv_period",
  "ind_op_short_adv_flag"
)

indicator_eligible_mask <- function(dt, indicator) {
  flags <- get_proc_flags(dt)
  if (indicator %in% IND_COMPETITIVE_ONLY) return(flags$competitive)
  if (indicator %in% IND_OPEN_ONLY)        return(flags$open)
  rep(TRUE, nrow(dt))
}

## ProACT Dashboard Export Function ####

## --------------------------------------------------
## CHANGE (A3): calculate_proact_aggregates now:
## - computes missing_share ONLY within eligible sample
## - outputs 2 new columns: missing_share, passes_missingness_30
## --------------------------------------------------
calculate_proact_aggregates <- function(dt, indicator) {
  if (!is.data.table(dt)) dt <- as.data.table(dt)

  has_price_data <- "bid_priceusd" %in% names(dt) && sum(!is.na(dt$bid_priceusd)) > 0

  calc_stats <- function(subset_dt) {
    if (nrow(subset_dt) == 0) {
      return(list(
        mean_val = NA_real_,
        numerator = NA_integer_,
        denominator = NA_integer_,
        n_obs = 0L,
        total_value = NA_real_,
        missing_share = NA_real_,
        passes = 0L
      ))
    }

    elig <- indicator_eligible_mask(subset_dt, indicator)
    n_eligible <- sum(elig, na.rm = TRUE)

    # Non-missing among eligible
    n_non_missing <- if (n_eligible == 0) 0L else sum(!is.na(subset_dt[[indicator]]) & elig)

    miss_share <- if (n_eligible == 0) NA_real_ else (n_eligible - n_non_missing) / n_eligible
    passes <- if (!is.na(miss_share) && miss_share <= MISSINGNESS_THRESHOLD) 1L else 0L

    vals <- subset_dt[[indicator]]

    list(
      mean_val = if (n_eligible == 0) NA_real_ else round(mean(vals[elig], na.rm = TRUE), 2),
      numerator = if (n_eligible == 0) NA_integer_ else sum(vals[elig] == 1, na.rm = TRUE),
      denominator = n_non_missing,              # eligible+observed for indicator
      n_obs = nrow(subset_dt),                  # tier sample size 
      total_value = sum(subset_dt$bid_priceusd, na.rm = TRUE) / 1e6,
      missing_share = miss_share,
      passes = passes
    )
  }

  if (!has_price_data) {
    return(data.table(
      Indicator = indicator,
      Contract_value = c("HIGH", "MED", "LOW"),
      Indicator_value = rep(NA_real_, 3),
      Total_number_of_risky_contracts = rep(NA_integer_, 3),
      All_contracts = rep(NA_integer_, 3),
      n_observations = rep(NA_integer_, 3),
      Total_contract_value_million_usd = rep(NA_real_, 3),

      # CHANGE (A3): 
      missing_share = rep(NA_real_, 3),
      passes_missingness_30 = rep(0L, 3)
    ))
  }

  setorder(dt, -bid_priceusd)

  high_stats <- calc_stats(dt[!is.na(bid_priceusd) & bid_priceusd >= 400000])
  med_stats  <- calc_stats(dt[!is.na(bid_priceusd) & bid_priceusd >= 50000 & bid_priceusd < 400000])
  low_stats  <- calc_stats(dt[!is.na(bid_priceusd) & bid_priceusd < 50000])

  data.table(
    Indicator = indicator,
    Contract_value = c("HIGH", "MED", "LOW"),
    Indicator_value = c(high_stats$mean_val, med_stats$mean_val, low_stats$mean_val),
    Total_number_of_risky_contracts = c(high_stats$numerator, med_stats$numerator, low_stats$numerator),
    All_contracts = c(high_stats$denominator, med_stats$denominator, low_stats$denominator),
    n_observations = c(high_stats$n_obs, med_stats$n_obs, low_stats$n_obs),
    Total_contract_value_million_usd = round(c(high_stats$total_value, med_stats$total_value, low_stats$total_value), 2),

    # CHANGE (A3): minimal additions
    missing_share = c(high_stats$missing_share, med_stats$missing_share, low_stats$missing_share),
    passes_missingness_30 = c(high_stats$passes, med_stats$passes, low_stats$passes)
  )
}

# III. Load and process files ####
files_to_load <- list.files(opt$`input-dir`, pattern="_export\\.csv$", full.names=TRUE, recursive = TRUE)
stopifnot(length(files_to_load) > 0)

file_info <- data.table(
  filepath = files_to_load,
  filename = basename(files_to_load)
)
file_info[, country_code := substr(filename, 1, 2)]

if (any(grepl("\\d{8}", file_info$filename))) {
  file_info[, date_str := sub(".*_(\\d{8})_.*", "\\1", filename)]
  file_info <- file_info[order(-date_str)]
  file_info <- file_info[, .SD[1], by = country_code]
}

file_info <- file_info[order(country_code)]
files_to_load <- file_info$filepath
vcat("Selected %d files", length(files_to_load))

proact_export_all <- list()

## --------------------------------------------------
## DIAGNOSTICS collectors across countries
## --------------------------------------------------
adv_period_diag_all   <- list()
price_tier_counts_all <- list()
price_tertiles_all    <- list()

available_indicators_by_country <- list()
missing_indicators_by_country   <- list()

for (file_path in files_to_load) {

  cat(sprintf("\n=== Processing: %s ===\n", basename(file_path)))

  df <- fread(file_path)
  cat(sprintf("  Loaded %d rows, %d columns\n", nrow(df), ncol(df)))

  # ---- DROP DUPLICATED LOGICAL COLUMNS (KEEP FIRST) ----
  base_names <- sub("\\..*$", "", names(df))
  dup_base <- base_names[duplicated(base_names)]
  if (length(dup_base) > 0) {
    warning(sprintf(
      "Dropping duplicated columns (keeping first): %s",
      paste(unique(dup_base), collapse = ", ")
    ))
    keep <- !duplicated(base_names)
    df <- df[, ..keep]
  }

  # Extract country code from tender_country column (ISO2)
  if (!"tender_country" %in% names(df)) {
    stop(sprintf("Column 'tender_country' not found in file: %s\nAvailable columns: %s",
                 basename(file_path), paste(head(names(df), 10), collapse=", ")))
  }

  country_codes <- unique(df$tender_country)
  country_codes <- country_codes[!is.na(country_codes)]
  if (length(country_codes) == 0) stop(sprintf("No valid country codes found in tender_country column for file: %s", basename(file_path)))
  if (length(country_codes) > 1) {
    warning(sprintf("Multiple country codes found in %s: %s. Using first one.",
                    basename(file_path), paste(country_codes, collapse=", ")))
  }
  country_code <- country_codes[1]

  country_match <- iso_matcher[iso2 == country_code]
  if (nrow(country_match) == 0) {
    warning(sprintf("Country code '%s' not found in ISO matcher. Using code as name.", country_code))
    country_name <- country_code
  } else {
    country_name <- country_match$country[1]
  }

  cat(sprintf("  Country: %s (%s)\n", country_name, country_code))

  # Create tender_year from date columns with fallback logic
  date_cols <- c(
    "tender_publications_firstdcontractawarddate",
    "tender_contractsignaturedate",
    "tender_awarddecisiondate",
    "tender_biddeadline",
    "tender_publications_firstcallfortenderdate"
  )

  parse_date_robust <- function(x) {
    if (is.null(x) || length(x) == 0) return(as.Date(NA))
    if (inherits(x, "Date")) return(x)
    if (inherits(x, c("POSIXct", "POSIXlt"))) return(as.Date(x))
    if (is.numeric(x)) return(as.Date(x, origin = "1899-12-30"))
    x_char <- as.character(x)
    parsed <- suppressWarnings(mdy(x_char))
    if (all(is.na(parsed))) parsed <- suppressWarnings(dmy(x_char))
    if (all(is.na(parsed))) parsed <- suppressWarnings(ymd(x_char))
    if (all(is.na(parsed))) parsed <- suppressWarnings(as.Date(x_char))
    parsed
  }

  for (col in date_cols) {
    if (col %in% names(df)) {
      parsed_col_name <- paste0(col, "_parsed")
      df[, (parsed_col_name) := parse_date_robust(get(col))]
      success_rate <- sum(!is.na(df[[parsed_col_name]])) / nrow(df) * 100
      if (success_rate < 50) {
        cat(sprintf("  WARNING: %s has low parse rate (%.1f%% successful)\n", col, success_rate))
      }
    }
  }

  df[, tender_year := NA_integer_]
  if ("tender_publications_firstdcontractawarddate_parsed" %in% names(df)) {
    df[is.na(tender_year), tender_year := year(tender_publications_firstdcontractawarddate_parsed)]
  }
  if ("tender_contractsignaturedate_parsed" %in% names(df)) {
    df[is.na(tender_year), tender_year := year(tender_contractsignaturedate_parsed)]
  }
  if ("tender_awarddecisiondate_parsed" %in% names(df)) {
    df[is.na(tender_year), tender_year := year(tender_awarddecisiondate_parsed)]
  }
  if ("tender_biddeadline_parsed" %in% names(df)) {
    df[is.na(tender_year), tender_year := year(tender_biddeadline_parsed)]
  }
  if ("tender_publications_firstcallfortenderdate_parsed" %in% names(df)) {
    df[is.na(tender_year), tender_year := year(tender_publications_firstcallfortenderdate_parsed)]
  }

  year_success_rate <- sum(!is.na(df$tender_year)) / nrow(df) * 100
  cat(sprintf("  tender_year created: %.1f%% of rows have valid year\n", year_success_rate))

  parsed_cols <- paste0(date_cols, "_parsed")
  df[, (parsed_cols) := NULL]

  rows_before <- nrow(df)
  cat(sprintf("  Rows before year filter: %d\n", rows_before))

  df <- df[tender_year >= 2000 & tender_year <= 2020]

  rows_after <- nrow(df)
  cat(sprintf("  Rows after year filter (2000-2020): %d (%.1f%% retained)\n",
              rows_after, rows_after/rows_before*100))

  if (rows_after == 0) {
    warning(sprintf("NO ROWS REMAINING after year filter for %s! Check date columns.", country_code))
    cat("  Year distribution in original data:\n")
    print(table(df[, tender_year], useNA = "ifany"))
    next
  }

  vcat("  Year distribution: %s", paste(names(table(df$tender_year)), collapse=", "))

  # Process lot_productcode -> product_market_short_name
  if ("lot_productcode" %in% names(df)) {
    na_count <- sum(is.na(df$lot_productcode))
    cat(sprintf("  lot_productcode: %d non-NA (%.1f%%)\n",
                nrow(df) - na_count, (nrow(df) - na_count)/nrow(df)*100))

    df[, cpv_first2 := substr(as.character(lot_productcode), 1, 2)]
    df[, cpv_code_numeric := suppressWarnings(as.numeric(cpv_first2))]
    matchable <- sum(!is.na(df$cpv_code_numeric))
    cat(sprintf("  Matchable CPV codes: %d (%.1f%%)\n",
                matchable, matchable/nrow(df)*100))

    df <- merge(df,
                correspondence_table[, .(cpv_code, product_market_short_name)],
                by.x = "cpv_code_numeric",
                by.y = "cpv_code",
                all.x = TRUE,
                sort = FALSE)

    matched <- sum(!is.na(df$product_market_short_name))
    cat(sprintf("  Matched to markets: %d (%.1f%%)\n",
                matched, matched/nrow(df)*100))

    df[, c("cpv_first2", "cpv_code_numeric") := NULL]
  } else {
    warning("Column 'lot_productcode' not found. Creating NA product_market_short_name.")
    df[, product_market_short_name := NA_character_]
  }

  # Handle tender_supplytype
  if (!"tender_supplytype" %in% names(df)) {
    warning(sprintf("Column 'tender_supplytype' not found in %s. Creating NA column.", country_code))
    cat("  ? tender_supplytype: COLUMN NOT FOUND - all values will be NA\n")
    df[, tender_supplytype := NA_character_]
  } else {
    df[, tender_supplytype := str_to_title(as.character(tender_supplytype))]
    supplytype_na <- sum(is.na(df$tender_supplytype))
    supplytype_available <- nrow(df) - supplytype_na

    if (supplytype_available == 0) {
      cat(sprintf("  ? tender_supplytype: 0 non-NA (0%%) - all values are NA\n"))
    } else {
      cat(sprintf("  ? tender_supplytype: %s non-NA (%.1f%%)\n",
                  format(supplytype_available, big.mark=","),
                  (supplytype_available/nrow(df)*100)))

      supply_dist <- table(df$tender_supplytype, useNA = "ifany")
      cat(sprintf("    Distribution: "))
      for (i in seq_along(supply_dist)) {
        type_name <- names(supply_dist)[i]
        if (is.na(type_name)) type_name <- "NA"
        cat(sprintf("%s: %s (%.1f%%)",
                    type_name,
                    format(supply_dist[i], big.mark=","),
                    supply_dist[i]/nrow(df)*100))
        if (i < length(supply_dist)) cat(", ")
      }
      cat("\n")
    }
  }

  # Handle bid_priceusd
  if (!"bid_priceusd" %in% names(df)) {
    warning(sprintf("Column 'bid_priceusd' not found in %s. All price tiers will be NA.", country_code))
    cat("  ? bid_priceusd: COLUMN NOT FOUND - price tiers will be NA\n")
    df[, bid_priceusd := NA_real_]
  } else {
    if (is.integer(df$bid_priceusd)) {
      cat(sprintf("  Converting bid_priceusd to numeric for country %s\n", country_code))
      df[, bid_priceusd := as.numeric(bid_priceusd)]
    }

    price_na <- sum(is.na(df$bid_priceusd))
    price_available <- nrow(df) - price_na

    if (price_available == 0) {
      cat(sprintf("  ? bid_priceusd: 0 non-NA (0%%) - ALL price tiers will be NA\n"))
    } else {
      cat(sprintf("  ? bid_priceusd: %s non-NA (%.1f%%), median: $%s\n",
                  format(price_available, big.mark=","),
                  (price_available/nrow(df)*100),
                  format(round(median(df$bid_priceusd, na.rm=TRUE)), big.mark=",")))

high_count <- sum(!is.na(df$bid_priceusd) & df$bid_priceusd >= 400000)
med_count  <- sum(!is.na(df$bid_priceusd) & df$bid_priceusd >= 50000 & df$bid_priceusd < 400000)
low_count  <- sum(!is.na(df$bid_priceusd) & df$bid_priceusd < 50000)



     cat(sprintf(
  "    HIGH (>= $400K): %s (%.1f%%), MED ($50K–$399K): %s (%.1f%%), LOW (< $50K): %s (%.1f%%)\n",
  format(high_count, big.mark=","), high_count / price_available * 100,
  format(med_count,  big.mark=","), med_count  / price_available * 100,
  format(low_count,  big.mark=","), low_count  / price_available * 100
))
}
  }

  # Add Country and Country_code
  df[, Country := country_name]
  df[, Country_code := country_code]

  cat(sprintf("  Data ready for aggregation: %s rows\n", format(nrow(df), big.mark=",")))

  na_markets <- sum(is.na(df$product_market_short_name))
  if (na_markets > 0) {
    cat(sprintf("  Note: %s rows (%.1f%%) have NA product_market_short_name\n",
                format(na_markets, big.mark=","),
                na_markets/nrow(df)*100))
  }

  available_indicators <- intersect(list_of_indicators, names(df))
  missing_indicators <- setdiff(list_of_indicators, names(df))

  available_indicators_by_country[[country_code]] <- available_indicators
  missing_indicators_by_country[[country_code]] <- missing_indicators

  if (length(available_indicators) == 0) {
    warning(sprintf("No indicators found in data for %s!", country_code))
    next
  }

  if (length(missing_indicators) > 0) {
    cat(sprintf("  Skipping %d missing indicators: %s\n",
                length(missing_indicators),
                paste(head(missing_indicators, 3), collapse=", ")))
    if (length(missing_indicators) > 3) {
      cat(sprintf("    ... and %d more\n", length(missing_indicators) - 3))
    }
  }

  # --------------------------------------------------
  # DIAGNOSTICS — compute per-country AFTER core cleaning
  # --------------------------------------------------

  # OPEN mask
  open_mask <- rep(NA, nrow(df))
  if ("tender_proceduretype" %in% names(df)) {
    proc_clean <- toupper(trimws(as.character(df$tender_proceduretype)))
    open_mask <- !is.na(proc_clean) & proc_clean == "OPEN"
  }

  ## --------------------------------------------------
  ## CHANGE (B1): Add COMPETITIVE mask (OPEN + RESTRICTED)
  ## --------------------------------------------------
  competitive_mask <- rep(NA, nrow(df))
  if ("tender_proceduretype" %in% names(df)) {
    proc_clean <- toupper(trimws(as.character(df$tender_proceduretype)))
    competitive_mask <- !is.na(proc_clean) & proc_clean %in% c("OPEN", "RESTRICTED")
  }

  # Contract value tier label
  if ("bid_priceusd" %in% names(df) && sum(!is.na(df$bid_priceusd)) > 0) {
df[, contract_value_tier := fifelse(
  is.na(bid_priceusd), NA_character_,
  fifelse(bid_priceusd >= 400000, "HIGH",
          fifelse(bid_priceusd >= 50000, "MED", "LOW"))
)]
  } else {
    df[, contract_value_tier := NA_character_]
  }

  # 1) Adv/submission period diagnostics (OPEN only)
  adv_period_var <- NA_character_
  if ("ind_op_adv_period" %in% names(df)) {
    adv_period_var <- "ind_op_adv_period"
  } else if ("ind_op_subm_period" %in% names(df)) {
    adv_period_var <- "ind_op_subm_period"
  }

  if (!is.na(adv_period_var) && any(open_mask == TRUE, na.rm = TRUE) && any(!is.na(df$contract_value_tier))) {
    tmp_adv <- df[open_mask == TRUE & !is.na(contract_value_tier),
                  .(
                    n_rows_open = .N,
                    n_period_nonmissing = sum(!is.na(get(adv_period_var))),
                    mean_period = mean(get(adv_period_var), na.rm = TRUE),
                    sd_period   = sd(get(adv_period_var), na.rm = TRUE)
                  ),
                  by = .(Country, Country_code, contract_value_tier)
    ]
    tmp_adv[, period_variable_used := adv_period_var]
    tmp_adv[, procedure_filter := "OPEN"]
    setcolorder(tmp_adv, c("Country","Country_code","procedure_filter","period_variable_used",
                           "contract_value_tier","n_rows_open","n_period_nonmissing","mean_period","sd_period"))
    adv_period_diag_all[[country_code]] <- tmp_adv
  } else {
    adv_period_diag_all[[country_code]] <- data.table(
      Country = country_name,
      Country_code = country_code,
      procedure_filter = "OPEN",
      period_variable_used = adv_period_var,
      contract_value_tier = c("HIGH","MED","LOW"),
      n_rows_open = NA_integer_,
      n_period_nonmissing = NA_integer_,
      mean_period = NA_real_,
      sd_period = NA_real_
    )
  }

  # 2a) Fixed tiers counts (ALL vs OPEN vs COMPETITIVE)
  if ("bid_priceusd" %in% names(df) && sum(!is.na(df$bid_priceusd)) > 0) {
    df_price <- df[!is.na(bid_priceusd)]
    df_price[, scope := "ALL"]

    df_price_open <- df[open_mask == TRUE & !is.na(bid_priceusd)]
    df_price_open[, scope := "OPEN"]

    ## CHANGE (B2): Competitive price subset
    df_price_comp <- df[competitive_mask == TRUE & !is.na(bid_priceusd)]
    df_price_comp[, scope := "COMPETITIVE"]

    count_tiers <- function(dtx) {
  data.table(
    n_price = nrow(dtx),
    n_high = sum(dtx$bid_priceusd >= 400000),
    n_med  = sum(dtx$bid_priceusd >= 50000 & dtx$bid_priceusd < 400000),
    n_low  = sum(dtx$bid_priceusd < 50000)
  )
}


    tiers_all  <- count_tiers(df_price)
    tiers_open <- if (nrow(df_price_open) > 0) count_tiers(df_price_open) else data.table(n_price=0, n_high=0, n_med=0, n_low=0)
    tiers_comp <- if (nrow(df_price_comp) > 0) count_tiers(df_price_comp) else data.table(n_price=0, n_high=0, n_med=0, n_low=0)

    tmp_tiers <- rbind(
      cbind(data.table(Country=country_name, Country_code=country_code, scope="ALL"),         tiers_all),
      cbind(data.table(Country=country_name, Country_code=country_code, scope="OPEN"),        tiers_open),
      cbind(data.table(Country=country_name, Country_code=country_code, scope="COMPETITIVE"), tiers_comp)
    )
    price_tier_counts_all[[country_code]] <- tmp_tiers

    # 2b) Tertiles counts (ALL vs OPEN vs COMPETITIVE) + cutpoints
    x_all <- df_price$bid_priceusd
    q_all <- as.numeric(quantile(x_all, probs = c(1/3, 2/3), na.rm = TRUE, type = 7))

    df_price[, tertile := fifelse(
      bid_priceusd <= q_all[1], 1L,
      fifelse(bid_priceusd <= q_all[2], 2L, 3L)
    )]
    tert_all <- df_price[, .(n = .N), by = .(Country, Country_code, scope, tertile)]
    tert_all[, tertile_cut_33 := q_all[1]]
    tert_all[, tertile_cut_66 := q_all[2]]

    tert_open <- NULL
    if (nrow(df_price_open) > 0) {
      x_open <- df_price_open$bid_priceusd
      q_open <- as.numeric(quantile(x_open, probs = c(1/3, 2/3), na.rm = TRUE, type = 7))

      df_price_open[, tertile := fifelse(
        bid_priceusd <= q_open[1], 1L,
        fifelse(bid_priceusd <= q_open[2], 2L, 3L)
      )]
      tert_open <- df_price_open[, .(n = .N), by = .(Country, Country_code, scope, tertile)]
      tert_open[, tertile_cut_33 := q_open[1]]
      tert_open[, tertile_cut_66 := q_open[2]]
    }

    ## CHANGE (B3): Competitive tertiles
    tert_comp <- NULL
    if (nrow(df_price_comp) > 0) {
      x_comp <- df_price_comp$bid_priceusd
      q_comp <- as.numeric(quantile(x_comp, probs = c(1/3, 2/3), na.rm = TRUE, type = 7))

      df_price_comp[, tertile := fifelse(
        bid_priceusd <= q_comp[1], 1L,
        fifelse(bid_priceusd <= q_comp[2], 2L, 3L)
      )]
      tert_comp <- df_price_comp[, .(n = .N), by = .(Country, Country_code, scope, tertile)]
      tert_comp[, tertile_cut_33 := q_comp[1]]
      tert_comp[, tertile_cut_66 := q_comp[2]]
    }

    tmp_tertiles <- rbindlist(list(tert_all, tert_open, tert_comp), fill = TRUE)
    setcolorder(tmp_tertiles, c("Country","Country_code","scope","tertile_cut_33","tertile_cut_66","tertile","n"))
    price_tertiles_all[[country_code]] <- tmp_tertiles
  } else {
    price_tier_counts_all[[country_code]] <- data.table(
      Country = country_name,
      Country_code = country_code,
      scope = c("ALL","OPEN","COMPETITIVE"),
      n_price = NA_integer_,
      n_high = NA_integer_,
      n_med = NA_integer_,
      n_low = NA_integer_
    )
    price_tertiles_all[[country_code]] <- data.table(
      Country = country_name,
      Country_code = country_code,
      scope = c("ALL","OPEN","COMPETITIVE"),
      tertile_cut_33 = NA_real_,
      tertile_cut_66 = NA_real_,
      tertile = NA_integer_,
      n = NA_integer_
    )
  }

  # Calculate ProACT aggregates grouped by Country, year, market, supply type
  proact_export <- df[, {
    rbindlist(lapply(available_indicators, function(ind) {
      calculate_proact_aggregates(.SD, ind)
    }))
  }, by = .(Country, Country_code, tender_year, product_market_short_name, tender_supplytype)]

  ## --------------------------------------------------
  ## CHANGE (A4): Do NOT drop rows failing missingness.
  ## Instead: redefine Indicator_availability_filter to require:
  ##  - indicator value exists AND
  ##  - passes_missingness_30 == 1
  ## --------------------------------------------------
  proact_export[, Indicator_availability_filter := fifelse(
    !is.na(Indicator_value) & passes_missingness_30 == 1L,
    1L, 0L
  )]

  ## --------------------------------------------------
  ## CHANGE (A5): Console log missingness failures per country (requested)
  ## --------------------------------------------------
  fail_n <- proact_export[!is.na(missing_share) & passes_missingness_30 == 0L, .N]
  if (fail_n > 0) {
    cat(sprintf("  Missingness>30%%: %s rows flagged (not dropped)\n", format(fail_n, big.mark=",")))
  } else {
    cat("  Missingness>30%: none flagged\n")
  }

  # Log aggregation results (same style)
  na_market_rows <- sum(is.na(proact_export$product_market_short_name))
  if (na_market_rows > 0) {
    cat(sprintf("  Note: %s output rows (%.1f%%) have NA product_market_short_name\n",
                format(na_market_rows, big.mark=","),
                na_market_rows/nrow(proact_export)*100))
  }

  na_supplytype_rows <- sum(is.na(proact_export$tender_supplytype))
  if (na_supplytype_rows > 0) {
    cat(sprintf("  Note: %s output rows (%.1f%%) have NA tender_supplytype\n",
                format(na_supplytype_rows, big.mark=","),
                na_supplytype_rows/nrow(proact_export)*100))
  }

  available_rows <- sum(proact_export$Indicator_availability_filter == 1)
  cat(sprintf("  Data availability (after filter flag): %s rows flagged as available (%.1f%%)\n",
              format(available_rows, big.mark=","),
              available_rows/nrow(proact_export)*100))

  proact_export_all[[country_code]] <- proact_export

  cat(sprintf("  ? Completed %s: Generated %s rows of aggregated data\n",
              country_code,
              format(nrow(proact_export), big.mark=",")))
}

cat("\n=== All countries processed ===\n")

# --------------------------------------------------
# EXPORT DIAGNOSTICS (after all countries)
# --------------------------------------------------
cat("\nExporting diagnostics...\n")

adv_period_diag <- rbindlist(adv_period_diag_all, fill = TRUE)
adv_outfile <- file.path(out_dir, "DIAG_adv_or_subm_period_OPEN_by_value_tier_country.csv")
fwrite(adv_period_diag, adv_outfile)
cat(sprintf("  Wrote: %s\n", adv_outfile))

price_tier_counts <- rbindlist(price_tier_counts_all, fill = TRUE)
## CHANGE (B4): filename still OK; now contains COMPETITIVE too
price_tier_outfile <- file.path(out_dir, "DIAG_bid_priceusd_fixed_tiers_counts_ALL_vs_OPEN_vs_COMPETITIVE_by_country.csv")
fwrite(price_tier_counts, price_tier_outfile)
cat(sprintf("  Wrote: %s\n", price_tier_outfile))

price_tertiles <- rbindlist(price_tertiles_all, fill = TRUE)
## CHANGE (B5): filename updated to reflect COMPETITIVE
price_tertiles_outfile <- file.path(out_dir, "DIAG_bid_priceusd_tertiles_counts_ALL_vs_OPEN_vs_COMPETITIVE_by_country.csv")
fwrite(price_tertiles, price_tertiles_outfile)
cat(sprintf("  Wrote: %s\n", price_tertiles_outfile))

# Indicator availability by country
avail_dbg <- rbindlist(lapply(names(available_indicators_by_country), function(cc) {
  data.table(Country_code = cc, Indicator = available_indicators_by_country[[cc]], status = "available")
}), fill = TRUE)
miss_dbg <- rbindlist(lapply(names(missing_indicators_by_country), function(cc) {
  data.table(Country_code = cc, Indicator = missing_indicators_by_country[[cc]], status = "missing_in_df")
}), fill = TRUE)
ind_dbg <- rbindlist(list(avail_dbg, miss_dbg), fill = TRUE)
ind_dbg_outfile <- file.path(out_dir, "DIAG_indicator_availability_by_country.csv")
fwrite(ind_dbg, ind_dbg_outfile)
cat(sprintf("  Wrote: %s\n", ind_dbg_outfile))

# IV. Combine and export ####
cat("\nCombining all country tables...\n")
proact_combined <- rbindlist(proact_export_all)
cat(sprintf("Combined dataset: %d rows, %d columns\n", nrow(proact_combined), ncol(proact_combined)))

cat("Matching indicator names with labels...\n")
proact_combined[, Indicator_original_name := Indicator]

proact_combined <- merge(proact_combined,
                         ind_names_lookup[, .(Indicator_name_in_dataset, Indicator_NEW_short_50)],
                         by.x = "Indicator_original_name",
                         by.y = "Indicator_name_in_dataset",
                         all.x = TRUE,
                         sort = FALSE)

unmatched_ind <- proact_combined[is.na(Indicator_NEW_short_50), unique(Indicator_original_name)]
if (length(unmatched_ind) > 0) {
  warning(sprintf("Indicators without label match: %s", paste(unmatched_ind, collapse = ", ")))
  cat(sprintf("  ? WARNING: %d indicators have no label match and will keep original names\n", length(unmatched_ind)))
}

proact_combined[, Indicator := fifelse(is.na(Indicator_NEW_short_50),
                                      Indicator_original_name,
                                      Indicator_NEW_short_50)]
proact_combined[, Indicator_NEW_short_50 := NULL]

other_cols <- setdiff(names(proact_combined), c("Indicator", "Indicator_original_name"))
setcolorder(proact_combined, c("Indicator", "Indicator_original_name", other_cols))

cat(sprintf("Indicator labels applied: %d unique indicators\n",
            length(unique(proact_combined$Indicator))))

add_iso3 <- function(dt, iso_matcher) {
  if (!is.data.table(dt)) setDT(dt)

  dt <- merge(dt, iso_matcher[, .(iso2, iso3)],
              by.x = "Country_code", by.y = "iso2",
              all.x = TRUE, sort = FALSE)

  dt[Country_code == "EU", iso3 := "EUE"]

  unmatched <- dt[is.na(iso3), unique(Country_code)]
  if (length(unmatched) > 0) {
    warning(sprintf("ISO3 matching: No match found for Country_code(s): %s",
                    paste(unmatched, collapse = ", ")))
    vcat("WARNING: ISO3 matching failed for: %s", paste(unmatched, collapse = ", "))
  }

  setnames(dt, "Country_code", "Country_code_ISO_2")
  setnames(dt, "iso3", "Country_code_ISO_3")
  dt
}

cat("Adding ISO3 codes...\n")
proact_combined <- add_iso3(proact_combined, iso_matcher)
cat("ISO3 codes added successfully\n")

setcolorder(proact_combined, c(
  "Country", "Country_code_ISO_2", "Country_code_ISO_3",
  "Indicator", "Indicator_original_name",
  setdiff(names(proact_combined), c("Country", "Country_code_ISO_2", "Country_code_ISO_3",
                                    "Indicator", "Indicator_original_name"))
))

proact_combined[proact_combined == "NaN"] <- NA

output_file <- file.path(out_dir, "ProACT_dashboard_export.csv")
cat(sprintf("\nExporting to: %s\n", output_file))
fwrite(proact_combined, output_file)

cat(sprintf("\n=== ? Export complete! ===\n"))
cat(sprintf("Output file: %s\n", output_file))
cat(sprintf("Total rows exported: %s\n", format(nrow(proact_combined), big.mark=",")))
cat(sprintf("Unique countries: %d\n", length(unique(proact_combined$Country_code_ISO_2))))
cat(sprintf("Year range: %d-%d\n",
            min(proact_combined$tender_year, na.rm=TRUE),
            max(proact_combined$tender_year, na.rm=TRUE)))

rows_with_data <- sum(proact_combined$Indicator_availability_filter == 1)
rows_with_na <- sum(proact_combined$Indicator_availability_filter == 0)
cat(sprintf("\nData completeness:\n"))
cat(sprintf("  Rows with data: %s (%.1f%%)\n",
            format(rows_with_data, big.mark=","),
            rows_with_data/nrow(proact_combined)*100))
cat(sprintf("  Rows with NA: %s (%.1f%%) - due to missing price data / filters\n",
            format(rows_with_na, big.mark=","),
            rows_with_na/nrow(proact_combined)*100))

cat(sprintf("\nDimension completeness:\n"))
supplytype_dist <- table(proact_combined$tender_supplytype, useNA = "ifany")
cat(sprintf("  Supply type distribution:\n"))
for (i in seq_along(supplytype_dist)) {
  type_name <- names(supplytype_dist)[i]
  if (is.na(type_name)) type_name <- "NA"
  cat(sprintf("    %s: %s rows (%.1f%%)\n",
              type_name,
              format(supplytype_dist[i], big.mark=","),
              supplytype_dist[i]/nrow(proact_combined)*100))
}

na_market_count <- sum(is.na(proact_combined$product_market_short_name))
if (na_market_count > 0) {
  cat(sprintf("\nUnmatched markets:\n"))
  cat(sprintf("  Rows with NA product_market: %s (%.1f%%)\n",
              format(na_market_count, big.mark=","),
              na_market_count/nrow(proact_combined)*100))

  na_by_country <- proact_combined[is.na(product_market_short_name),
                                   .N,
                                   by = Country_code_ISO_2]
  if (nrow(na_by_country) > 0) {
    cat("  By country:\n")
    for (i in 1:nrow(na_by_country)) {
      cat(sprintf("    %s: %s rows\n",
                  na_by_country$Country_code_ISO_2[i],
                  format(na_by_country$N[i], big.mark=",")))
    }
  }
}

countries_with_all_na <- proact_combined[, .(all_na = all(Indicator_availability_filter == 0)),
                                         by = Country_code_ISO_2][all_na == TRUE]
if (nrow(countries_with_all_na) > 0) {
  cat(sprintf("\n? Countries with ALL NA values (no usable data): %s\n",
              paste(countries_with_all_na$Country_code_ISO_2, collapse=", ")))
}
